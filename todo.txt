============================================= Tomorrow =============================================
- Should we discuss the identity block-sizes?
- Currently,


============================================= Following days =============================================
- Everything to Numba (Vectorize?) + Inplace + LUT + Prefetch + measure ops time + Further optimize Convs + Mod %67 + DTYPES!! (Do we always send minimal data types?)
- Divide by block size in block ReLU (in order not to exceed MSB dummy bits)

- What is up with .train() vs .eval() in simulated annealing? is this relevant to distortion_extraction as well?
- should we describe the 0x1 block size? (SHAI)
- discuss the 32 bits in 4x4 and 5x5 compared to 1x1
- What is the level of reporducibility of the results? (I think it's pretty good)
- Explore 32bits, use trunc and understand when things go wrong (Maybe we can retrain?)
- Consult Shai about codebase and acceptance date
- More samples in noise estimation
- What about bandwith? (Instead of ReLU)
- Make everything deterministic (especially distortion extraction)
- Discuss formats of plots and tables
- Understand high l2 distance
- activate fetcher each and every time
- ResNet101 with SNR?
- Should I further verify .train() vs .eval()?
- What about competitions?!
- Crypto Provider work with shapes, maybe all crypto-tensors consume too much space?
- Remove conv in CUDA?
- Given another try to conv decomposition! (What about the queue)
- Add noise to training for DReLU (Understand mean vs sum)
- Competition!
- Measurements with bandwidth = infinity (zeros-like)
============================================= Major =============================================
- Should FC and GAP be part of distortion?
- Try working with learning rate warmup!
- We really need to compare Porthos implementation to ours on the same machine..
- Have cryptoprovider work with shapes only!
- Verify that everything is sent as soon as we have it, and gotten as late as possible
- AWS!
- Find optimal stochastic ReLU params
- A more efficient bReLU (during training as well)
- A symmetric bReLU
- Verify +1 in integer_random
- MaxPool/ReLU flip
- Implement Load Balancing in ReLU (same as Porthos)
- Replace mult in ReLU with select share
- Send Image Size
- Download ImageNet
- Go over protocol again. Verify implementation
- out = out // self.trunc? or just shift? (out = backend.astype((out/self.trunc).round(), dtype=SIGNED_DTYPE))
- Vector2Scalar multiplication. (for the bReLU)

- CUDA:
    (*) https://docs.nvidia.com/deeplearning/cudnn/developer-guide/index.html
    (*) Finegrained CUDA (not alwayes) which depends on amount of DReLUs (Careful with small tensors). It seems that also convolutions might benefit from CUDA only in some cases. We have to split the cuda implementation again to happen only when needed. We should split to atomic GPU component and benchmark each with different sizes and decide in runtime which one to use
    (*) More groups convs, verify that GPU ops don't block (if I have for example a list of conv2d, which I can run in parallel, will they block each other?)
    (*) CUDA allows for intergers ops, why not convs? maybe matrix multiplication?
    (*) Consider subdividing convs to 2 or 4 groups, and then convert to integer and them add them up. Will it allow us to divide 64bit number to 8 instead of 16?
    (*) Build a proper conv2d_handler: CUDA parallelize conv2d by stacking (also for the 2 convs case)
    (*) CUDA is able to perform integer operations, conv2d is not available due to cudnn. Maybe we can use matrix multiplication instead? Or any other solution.
    (*) efficient CUDA r_shift


============================================= Paper notes =============================================
- Think about best ways to tell the story - probably bReLU to ~15% or so... and then stochastic DReLU (as it reveals no information)
- Do we want to add bandwidth graph
- Ablation on loss?
- shuffled based knapsack?
- Table: benchmark Conv2d on Cuda
- Analysis - Maybe will help in KnapSack separation (due to proper additivity)
- A paragraph on information leakage
- Float implementation
- Non matmul implementation
- Remove negligble ops (such as test for 1/2**64)
- We set real benchmark on (Datasets) and Tasks
- Added CUDA implementation
- We chose not to decompose to offline/online, but this can be done.
- We can use a small set of images to approximate distortion. Anyway, people share the structure of the network, which reveal some information. we unveil some resolution related information, but nothing about images content and weight content.
- Discarding MSB practically share no information, as weight decay is so common.
- A note about softmax and logits

============================================= Minor! =============================================
- Channel distortion random seed, and multi-GPUs

- Linearize loss and use it as a distortion measure
- Try https://github.com/tensorly/tensorly
- what about this piece of code??! - assert not backend.any(r == backend.iinfo(r.dtype).max):  # HERE (In PrivateCompareClient)
- Understand the += issue
- Can we optimize beta in P0/P1/P2?
- Try to make float conv2 with numba. If it works - verify that group conv is optimized
- Clean up threads
- Consider to implement PRF fetcher in a different approach
- Verify L and L-1
- Major refactoring - Bunch of redundancies
- Can some ReLU ops be fetched?
- 2 GPUs 3 parties
- Clip TRUNC every k'th conv
- Why first image is slow
- Start analysis (Analysis with noise to KnapSack matrix)
- Further datasets/architectures/models/tasks (Detection)
- Use eagerpy
- Use blocksize [1,0] or discard!
- Stochastic sign flips to training (to train stochastic DReLUs) + QAT (Add quantization noise (to allow for 32bit inference) - QAT
- Compare to EIGEN library
- Make forward_fetch and forward_regular
- Reorganize configs (from scratch) as well as models, parametrs and MMLab tools (Just download everything once more)
- make dummy in base class
- Some refactoring (All ops should have dummy option in base class) - Server ops should inherit SecureServerModuld class, and forward should have dummy option
- change everything from dummy_tensors to dummy_tensor_shape - there is no need to pass dummy_tensors
- random - Have torch do that! (Upgrade if needed)

======================================== Reading  =============================================
- Benchmark ops
- FALCON, 2pc, 3pc, OT, HE
- ABY3
- How can 3PC be converted to 2PC? (Using OT)
- Understand our Security level
- Go over protocols again
- Understand the math behind the protocols
- Understand detection and propose protocols for special layers
- Understand Porthos float2int and int2float methods
- Understand why P needs to be 67. Can't we use 3/5/7/11/13 etc.?

============================================= Lastly =============================================
- Simulated annealing (With very short finetuning every k steps? Use distortion as loss doesn't feel right)

============================================= Never =============================================
- Consider MultiThreaded ReLU
- Draw a bunch of block sizes and try to learn a model that would lead to additivity
- CRF
- Use newer torch version with inplace << and bit_wise and
- fuse with next layer in case np.all(self.block_sizes == [0, 1]) (Can save much..)
- Is GLOO slowing us down?
- How to convert to 2-parties? Triangular masking? can our approach be used in 2-parties
- Allow for softmax via maxpool derivative (Or FALCON implementation)
- Consider using batch size > 1 in distortion extraction (and infer few block sizes simultaneously)
- Soft start (alpha * relu + (1-alpha) * bReLU)
- Can we fuze mobilenet 1x1 and 3x3 convolutions?
- Finetune iterative (itertaive sub channels (with multiple training))
- Use loss as distortion measure
- COCO seg